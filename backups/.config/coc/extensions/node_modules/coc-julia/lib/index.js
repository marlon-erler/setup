"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/isexe/dist/cjs/posix.js
var require_posix = __commonJS({
  "node_modules/isexe/dist/cjs/posix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var isexe = async (path2, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat(await (0, promises_1.stat)(path2), options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.isexe = isexe;
    var sync = (path2, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat((0, fs_1.statSync)(path2), options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.sync = sync;
    var checkStat = (stat, options) => stat.isFile() && checkMode(stat, options);
    var checkMode = (stat, options) => {
      const myUid = options.uid ?? process.getuid?.();
      const myGroups = options.groups ?? process.getgroups?.() ?? [];
      const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
      if (myUid === void 0 || myGid === void 0) {
        throw new Error("cannot get uid or gid");
      }
      const groups = /* @__PURE__ */ new Set([myGid, ...myGroups]);
      const mod = stat.mode;
      const uid = stat.uid;
      const gid = stat.gid;
      const u = parseInt("100", 8);
      const g = parseInt("010", 8);
      const o = parseInt("001", 8);
      const ug = u | g;
      return !!(mod & o || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && myUid === 0);
    };
  }
});

// node_modules/isexe/dist/cjs/win32.js
var require_win32 = __commonJS({
  "node_modules/isexe/dist/cjs/win32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var isexe = async (path2, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat(await (0, promises_1.stat)(path2), path2, options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.isexe = isexe;
    var sync = (path2, options = {}) => {
      const { ignoreErrors = false } = options;
      try {
        return checkStat((0, fs_1.statSync)(path2), path2, options);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.sync = sync;
    var checkPathExt = (path2, options) => {
      const { pathExt = process.env.PATHEXT || "" } = options;
      const peSplit = pathExt.split(";");
      if (peSplit.indexOf("") !== -1) {
        return true;
      }
      for (let i = 0; i < peSplit.length; i++) {
        const p = peSplit[i].toLowerCase();
        const ext = path2.substring(path2.length - p.length).toLowerCase();
        if (p && ext === p) {
          return true;
        }
      }
      return false;
    };
    var checkStat = (stat, path2, options) => stat.isFile() && checkPathExt(path2, options);
  }
});

// node_modules/isexe/dist/cjs/options.js
var require_options = __commonJS({
  "node_modules/isexe/dist/cjs/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/isexe/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/isexe/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = exports2.posix = exports2.win32 = void 0;
    var posix = __importStar(require_posix());
    exports2.posix = posix;
    var win32 = __importStar(require_win32());
    exports2.win32 = win32;
    __exportStar(require_options(), exports2);
    var platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
    var impl = platform === "win32" ? win32 : posix;
    exports2.isexe = impl.isexe;
    exports2.sync = impl.sync;
  }
});

// node_modules/which/lib/index.js
var require_lib = __commonJS({
  "node_modules/which/lib/index.js"(exports2, module2) {
    var { isexe, sync: isexeSync } = require_cjs();
    var { join, delimiter, sep, posix } = require("path");
    var isWindows = process.platform === "win32";
    var rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()]);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join(pathPart, cmd);
    };
    var which2 = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p = getPathPart(envPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p = getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc2 = require("coc.nvim");

// src/ctx.ts
var import_coc = require("coc.nvim");
var import_node_child_process = require("node:child_process");
var import_node_fs = __toESM(require("node:fs"));
var import_node_os = __toESM(require("node:os"));
var import_node_path = __toESM(require("node:path"));
var import_which = __toESM(require_lib());
var Config = class {
  constructor() {
    this.cfg = import_coc.workspace.getConfiguration("julia");
  }
  get enabled() {
    return this.cfg.get("enabled");
  }
  get executablePath() {
    return this.cfg.get("executablePath");
  }
  get environmentPath() {
    return this.cfg.get("environmentPath");
  }
};
var Ctx = class {
  constructor(context) {
    this.context = context;
    this.pkging = false;
    this.config = new Config();
    this.lsProj = import_node_path.default.join(context.extensionPath, "server");
    if (!import_node_fs.default.existsSync(context.storagePath)) {
      import_node_fs.default.mkdirSync(context.storagePath);
    }
    const version = this.resolveJuliaVersion();
    this.sysimgDir = import_node_path.default.join(context.storagePath, `sysimg-${version}`);
    if (!import_node_fs.default.existsSync(this.sysimgDir)) {
      import_node_fs.default.mkdirSync(this.sysimgDir);
    }
  }
  resolveJuliaBin() {
    let bin = this.config.executablePath;
    if (bin.startsWith("~")) {
      bin = import_node_os.default.homedir() + bin.slice(1);
    }
    if (bin && import_node_fs.default.existsSync(bin)) {
      return bin;
    }
    const cmd = process.platform === "win32" ? "julia.exe" : "julia";
    return import_which.default.sync(cmd, { nothrow: true });
  }
  resolveJuliaVersion() {
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --startup-file=no --history-file=no -e "println(VERSION)"`;
    return (0, import_node_child_process.execSync)(cmd).toString().trim();
  }
  formatPkg(vals) {
    const pkgs = [];
    for (const val of vals) {
      const parts = val.split(" ");
      if (parts.length === 4 || parts.length === 5) {
        pkgs.push({
          state: parts[0],
          hash: parts[1],
          name: parts[2],
          version: parts[3],
          repo: parts[4] || ""
        });
      }
    }
    return pkgs;
  }
  async resolveMissingPkgs(projPath) {
    const bin = this.resolveJuliaBin();
    let cmd = `${bin} --project="${projPath}" --startup-file=no --history-file=no -e "using Pkg; Pkg.status()"`;
    const pkgs = this.formatPkg((0, import_node_child_process.execSync)(cmd).toString().split("\n"));
    if (pkgs.some((p) => p.state === "\u2192")) {
      const ok = await import_coc.window.showPrompt(
        "Some LanguageServer.jl deps are missing, would you like to install now?"
      );
      if (ok) {
        this.pkging = true;
        cmd = `${bin} --project="${projPath}" --startup-file=no --history-file=no -e "using Pkg; Pkg.instantiate()"`;
        await import_coc.window.createTerminal({ name: "coc-julia-ls" }).then((t) => t.sendText(cmd));
      }
    }
  }
  resolveEnvPath() {
    if (this.config.environmentPath) {
      return this.config.environmentPath;
    }
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --project=@. --startup-file=no --history-file=no -e "using Pkg; println(dirname(Pkg.Types.Context().env.project_file))"`;
    return (0, import_node_child_process.execSync)(cmd).toString().trim();
  }
  resolveSysimgPath() {
    const sysimgs = {
      darwin: "sys.dylib",
      linux: "sys.so",
      win32: "sys.dll"
    };
    const sysimg_name = sysimgs[process.platform];
    const sysimg = import_node_path.default.join(this.sysimgDir, sysimg_name);
    if (import_node_fs.default.existsSync(sysimg)) {
      return sysimg;
    }
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --project=${this.lsProj} --startup-file=no --history-file=no -e "print(Base.Sys.BINDIR)"`;
    const bindir = (0, import_node_child_process.execSync)(cmd).toString().trim();
    return import_node_path.default.join(import_node_path.default.dirname(bindir), "lib", "julia", sysimg_name);
  }
  async compileServerSysimg(args) {
    import_coc.window.showInformationMessage(
      "PackageCompiler.jl will take about 20 mins to compile..."
    );
    const bin = this.resolveJuliaBin();
    await import_coc.window.createTerminal({ name: "coc-julia-ls" }).then((t) => {
      args.unshift(import_node_path.default.join(this.lsProj, "src", "exec.jl"));
      const files = args.join(" ");
      const cmd = `${bin} --project=${this.lsProj} ${import_node_path.default.join(
        this.lsProj,
        "src",
        "compile.jl"
      )} -s ${this.lsProj} ${this.sysimgDir} ${files}`;
      t.sendText(cmd);
    });
  }
  prepareJuliaArgs() {
    const sysimg = this.resolveSysimgPath();
    const server = import_node_path.default.join(this.lsProj, "src", "server.jl");
    const args = [
      "--startup-file=no",
      "--history-file=no",
      `--sysimage=${sysimg}`,
      "--depwarn=no",
      `--project=${this.lsProj}`,
      server
    ];
    const env = this.resolveEnvPath();
    const depopPath = process.env.JULIA_DEPOT_PATH ? process.env.JULIA_DEPOT_PATH : "";
    return args.concat([
      env,
      "--debug=no",
      depopPath,
      this.context.storagePath
    ]);
  }
  async startServer() {
    await this.resolveMissingPkgs(this.lsProj);
    if (this.pkging)
      return;
    const command = this.resolveJuliaBin();
    const args = this.prepareJuliaArgs();
    const tmpdir = await import_coc.workspace.nvim.eval("$TMPDIR") || process.env.TMPDIR || process.env.TMP;
    const serverOptions = {
      command,
      args,
      options: { env: { ...process.env, TMPDIR: tmpdir } }
    };
    const clientOptions = {
      documentSelector: ["julia", "juliamarkdown"],
      initializationOptions: import_coc.workspace.getConfiguration("julia"),
      synchronize: {
        configurationSection: ["julia.lint"],
        fileEvents: import_coc.workspace.createFileSystemWatcher("**/*.{jl,jmd}")
      },
      progressOnInitialization: true,
      middleware: {
        provideCompletionItem: async (document, position, context, token, next) => {
          const option = context.option;
          const input = option.input.startsWith(option.word) ? option.input : option.word + option.input;
          const res = await next(
            document,
            position,
            context,
            token
          );
          const items = [];
          if (res && Array.isArray(res.items)) {
            for (const item of res.items) {
              if (item.textEdit && import_coc.TextEdit.is(item.textEdit) && (item.kind === 14 || item.kind === 17)) {
                const newText = item.textEdit.newText;
                if (!newText.startsWith(input)) {
                  const range = Object.assign({}, item.textEdit.range);
                  const start = import_coc.Position.create(
                    range.start.line,
                    range.start.character - input.length
                  );
                  const end = import_coc.Position.create(
                    range.end.line,
                    range.end.character
                  );
                  item.textEdit.newText = `${input}${newText}`;
                  item.textEdit.range = import_coc.Range.create(start, end);
                }
              }
              items.push(item);
            }
          }
          return { items, isIncomplete: res.isIncomplete };
        }
      }
    };
    const client = new import_coc.LanguageClient(
      "julia",
      "Julia Language Server",
      serverOptions,
      clientOptions
    );
    this.context.subscriptions.push(import_coc.services.registLanguageClient(client));
  }
};

// src/index.ts
async function activate(context) {
  const ctx = new Ctx(context);
  if (!ctx.config.enabled)
    return;
  const bin = ctx.resolveJuliaBin();
  if (!bin) {
    import_coc2.window.showMessage(`Can't find julia`, "warning");
    return;
  }
  await ctx.startServer();
  context.subscriptions.push(
    import_coc2.commands.registerCommand(
      "julia.CompileLanguageServerSysimg",
      async (...args) => {
        await ctx.compileServerSysimg(args);
      }
    )
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
